## slice及其衍生

Go的数组和早期的C/Rust一样，大小都是编译期确定的，即a := [n]int是不可行的，**数组长度必须为常量**。此外，数组长度是数组类型的一部分，不同于Java等语言，数组类型仅仅是元素类型[]，**Go的数组类型 = 元素类型[] + 数组长度**。

也正因为此，Go的数组类型不常用，我们常用的是切片(Slice)，或者叫动态数组，或者说是Java的ArrayList类型，它会动态改变大小。不同于数组，**Slice的类型 = 元素类型[]**，这里不包含长度。

Slice的创建，增长等源码均在runtime/slice.go中实现，感兴趣可以看看，平时我们说一个变量是Slice类型，指的是它是一个**SliceHeader类型**。一个SliceHeader包含三个字段，分别是指向底层元素数组的指针，长度和容量。

```go
type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
```

容量始终大于等于长度，通过内置函数len()和cap()我们可以获取一个Slice的长度和容量。Slice的一些基本操作，创建，切分我们就不说了。

如果函数传参传递一个数组，则会涉及到调用参数和函数参数的复制，即数组会被复制一份。而如果我们**传参传的是Slice，则复制的是SliceHeader，这仅仅涉及到三个基本类型的复制**，相对开销会小很多。所以在被调函数中我们可以访问到Slice的底层数组并进行修改。

这里说一下Slice的遍历，主要针对一些可能存在的坑进行叙述，首先是：

```go
for idx, val := range slice {
        // xxx
}
```

这样的做法相当常见，其中idx是切片下表，val是切片元素。但是要注意，val在所有循环中一直是一个不变的变量，循环期间会不断获取val的地址并重写这个地址上的值为slice[idx]的值，所以**val每次会被复制，且地址不变**。如果不想要复制切片元素产生的性能开销，则可以使用slice[idx]访问到底层数组上的元素，并且可以进行修改。

此外再来讨论关于内存泄露的一些点，如果引用了一个大切片的部分，那么相当于引用了整个切片，这就会导致大量内存得不到及时回收；可以考虑使用复制部分切片实现值传递，而非引用来切断引用关系。

切片内如果保存指针类型，也会有类似的情况，删除元素会因为底层数组收缩不及时，而继续持有引用，可以通过置为nil来实现。

最后，可以手动更改SliceHeader来实现强制类型转换，这里一般改的是底层数组指针的值。

### 字符串

字符串有些类似切片，我们先来看看StringHeader结构：

```go
type StringHeader struct {
    Data uintptr
    Len  int
}
```

可以看到，它就一个底层数组指针和长度组成，所以**字符串天然不可修改**，每次赋值和更改操作均会创建新的字符串。

字符串底层是[]byte，所以可以直接通过str[idx]进行访问，此外，也可以强制类型转换成[]byte，如果通过for range遍历，则会得到码点，此时便利则变成了一个[]rune类型的数组的遍历，rune本质是一个int32类型。

字符串支持Slice的切片操作，此时会生成新的字符串并拷贝数据。

## unsafe

Go保留了指针，但是却给予其一定的限制。所以有时候我们想像C语言那样实现对内存地址的完全访问和控制，就需要unsafe来帮我们。

Unsafe包下最关键的两个类型则是Pointer和uintptr，这两个类型加上普通类型的指针类型，三者有着以下的关系：![go_unsafe](go_unsafe.svg)

可以看到，Pointer作为一个中介存在。它可以把任意类型的指针类型转换成可用于数学运算的纯数字类型uintptr，uintptr像是一个int型指针的别名，Pointer是*int的别名，对，是一个int指针的别名。

在这里我详细说一下uintptr：官方注释写到：uintptr类型的值大到足够容纳任何类型的指针的值，所以可以看成一个C语言中的void*类型，个人理解。但是无论什么类型的指针，本质都是一个地址，地址全部是数字类型的，或者说，整型的，所以uintptr代表的就是这个“整型”类型，也可以说“内存地址”类型，而内存地址是支持数学运算的。

现在来看看uintptr和Pointer的区别：

* uintptr能进行数学运算，即加减地址去访问新的地址，但是它只是一个数字，不会被GC检测到，所以uintptr类型的变量所保存的地址可能已经被回收了，即这里的引用关系无法被GC知晓
* Pointer是一个对象，它的变量持有的地址会被视为存在引用，即这个变量引用了这个地址，所以会被GC检测，而因为Go存在栈动态扩展，所以栈上对象可能会被移动，或者GC整理内存触发的地址变更，而Pointer会响应这些变更，也即Pointer保存的地址一定是合法的，可用的，uintptr则没有这个保证。

我们来看一个例子：

```go
type Temp struct {
    a float64
    b int64
    c bool
}

func run() {
    t := Temp{
        a: 24.12,
        b: 12,
        c: true,
    }
    // 强制类型转换不是赋值，是原子性，啊也不对，强转本质只是解释方式改变，数据不变，所以一步到位
    pointerOfB := (*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(&t)) + 8))
    *pointerOfB += 6
    fmt.Println(t)
    // 这里因为存在中间变量赋值，假如，就在赋值刚刚完成之后发生了GC导致t地址变化，那么tempAddress是不会被更新的
    tempAddress := uintptr(unsafe.Pointer(&t)) + 8
    // 所以会导致这里出现非法地址访问
    // https://stackoverflow.com/questions/42067478/when-is-it-safe-in-go-to-reference-an-object-only-through-a-uintptr有解释
    badPointerOfB := (*int64)(unsafe.Pointer(tempAddress))
    *badPointerOfB += 6
    fmt.Println(t)
}
```

在理解这个例子之前，我们先看看Go结构体布局。Go称为互联网时代的C语言，很大部分原因是因为它和C很像，结构体布局亦是如此：

![](go_struct_memory.svg)

这里说一下空结构体，空结构体本身不占内存，所以在最前面时不占空间，但是如果空结构体在结构体最后，同时此时没有触发内存对齐，就会**触发编译器的强制对齐，目的是防止访问到下一个内存区域**。

所以结构体对象可以通过**合理排列字段，来实现更好地内存利用**。

我们回到上面的例子。两个更新Temp.b的方法都可以达到目的，但是Goland会给予第二种方式一个提示，大意：此方法可能造成非法地址访问。那为什么会这样呢？

首先我们通过Pointer得到t的地址，然后转换成uintptr进行四则运算，然后转换成Pointer，再转换成类型指针，解引用访问。仔细对比，无非是第二种方式多了一个临时变量去记录Temp的b字段的实际地址，那为什么这里不可以呢？因为可能在**赋值给tempAddress时发生了GC或者栈满了**，总之**Temp对象被移动了**，那此时tempAddress保存的就是一个非法的值了。

其实最关键的是tempAddress是一个uintptr类型的变量，它不会响应对象被移动，所以它仅仅保存一直值，当对象被移动时它不会得到任何通知去更新，而写在uintptr(Pointer)的值会永远因为Pointer去响应更新，此外强制类型转换仅仅是改变了解释这个内存地址上面的变量的方式，不存在被中断这一说，所以这是一个“连续性可响应”的操作。

其他操作，比如unsafe.Alignof()返回对象的对齐，如果对象是结构体，则是所有字段对齐的最大值，以此递归，如果是基本类型，就是本身大小；unsafe.Sizeof()返回对象内存大小，包含对齐大小；还有unsafe.Offsetof()返回字段距离结构体起始位置的大小，单位，字节。

## 并发

并发作为一个经久不衰的话题，我们自然不会落下，但是在叙述Go的并发之前，我想先说一下Go的内存模型，Go的内存模型无外乎大多数编程语言的设计，说到内存模型，一定会涉及变量可见性，因为**内存模型这个概念，就是为了对多个线程对于同一个变量的读写可见性描述**。而变量可见性的判断依据有一个很重要的**happen-before原则(以下简称h-b)**。

### happen-before

h-b更像是一个判断依据，通过它，我们可以**判断两个不同Go程的读写操作是否满足预期结果**。怎么理解这句话呢？首先，在多个Go程中，因为指令排序和Go程调度，又或者是L1缓存的存在，导致对于同一变量的读，不一定会读到另一个Go程写入的值，即**共享变量的更新可见性无法被保证**。而**满足h-b原则的两个读写操作，先写的更新一定会被后读的读所捕获，不满足h-b的读写则没有这样的结论**。

说白了h-b可以作为判断后读是否可以读到先写的值得一个依据，**它是判断这一结果的原则，而不是保证这一结果的原则**。

那为什么会引入h-b原则呢？因为在同一个Go程中，即使存在指令重排序，代码的执行结果也一定符合书写顺序，这是编译器可以保证的；但是在多个Go程中，则没有这种保证，对于Go程A，它看到的Go程B对于某一变量的写可能晚于自己的读，即使从源码来看这件事是不可能的。所以**我们急需一个原则去告诉我们，这个读操作到底能不能读到另一个Go程的更新？**这个原则就是h-b。对于两个事件r-w，如果r h-b于w，或者w h-b于r(**r happen-after w**)，则称它们之间存在顺序关系，但是**如果r 既不h-b于w，w也不h-b于r，那么我们称r-w两个事件是happen-concurrently，即并发的**。

如果上述官方术语让读者读不懂的话，我用一个简单的符号表示h-b，即'<'(小于号)。**a h-b b写成a < b，说明a事件先于b事件发生**。如果a和b不存在小于关系，我们就得不到这个结论(废话)。而**如果a >= b且b >= a，则a和b是并发的**。

编程语言一般都存在一些天然的h-b关系，同时还存在一些可以人为实现的h-b关系，或者可以由上述两者推导出来的h-b关系，**除此之外，都是无法确定h-b关系的**。

让我们来看看[官方文档](https://go.dev/ref/mem)对于这些的叙述：

* 在单线程中，对于一个变量的读写顺序就是书写顺序。
* 在多Go程中，只有满足如下准则，读操作才能读到写更新：
  * 读**从不**会h-b于写。
  * 在写读之间没有第二个写h-b在第一个写之后，且h-b在读之前。
* 再来一个更加犀利的准则，确保读可以读到写更新：
  * 写h-b于读。
  * 任何其他的写一定h-b于这个写或者被h-b于读(在读之后)。
* 如果没有这些准则，就需要手动添加同步原语以保证达到想要的效果。
* 此外，变量创建时的赋初值属于对变量的写操作。

那么在Go中存在哪些同步原语可以确保h-b呢？我们不妨来数数：

* init函数调用h-b于任何一个此go文件中的函数调用，h-a于所有它所引用的go文件的init函数调用。
* Go程的创建h-b于此Go程中的任何部分。
* Go程的销毁h-a于它的任何部分，但是h-c于它所在的函数任何部分；即Go程里新开的Go程退出时间我们无法确定，和它周围的代码是h-c关系。
* 对于一个无缓冲的chan，接收操作h-b于发送操作**结束**；发送操作h-b于接收操作**结束**。即接收/发送**开始**h-b于发送/接收的**结束**。
* 上述关于无缓冲chan的描述，换成h-a更好，即接收操作的完成一定h-a于发送操作开始，反之亦然，方便理解。
* 此外，close一个chan，会触发零值返回，所以close一个chan就像发送了一个零值一样，虽然有一些不同，但是在同步中的作用是类似的。
* 对于一个缓冲的chan，第K的接收操作先于第K+capacity个发送操作完成。
* Mutex锁实现的同步原语，无论是锁还是读写锁都存在m<n，有第m次释放锁先于n次加锁完成(即加锁函数返回)。
* sync.Once也可以实现，Once参数的调用(它的参数是个函数)早于所有对于Once.do()的调用完成(即Once.do()返回)。

关于channel，看一张图：

![go_chan](go_chan.svg)

现在来看看Go可能的同步使用方法。

最常用的就是chan。chan的灵活使用和Go强调的基于管道通信，CSP技术有着莫大的关系。除了简单的通过chan来实现happen-before以此来控制多Go程执行顺序之外，还有以下用法：

* 设置带缓冲的chan，实现最大并发控制。
* 作为信号通知，控制其他Go程的退出。
* 作为timer返回值使用，实现定时器功能。

然后就是Mutex/RWMutex，类似Java的锁和读写锁。就是普通的可重入锁，底层实现包含一个虚拟队列和资源值，通过CAS设置，失败了自旋/入队。

官网还有一个演示chan的用法，比如作为计时器，作为多选择并发请求响应选取。

```go
func main() {
    timeout := make(chan struct{}, 1)
    go func() {
        time.Sleep(3 * time.Second)
        timeout <- struct{}{}
    }()
    <-timeout
    fmt.Println("run")
}
```

需要注意，当涉及到信号控制，或者未来的数据到达时，需要给chan设置一个缓冲区大小，这样可以阻塞接收者而不会阻塞调用者；想象一下，如果接收者是一个耗时任务，当超时到了，发送超时信号的发送者反而会被阻塞，这肯定是我们不想看到的，尤其是有多个接收者时，另一个接收者反而被接收者阻塞了，所以**我们不应该阻塞发送者，就应该设置缓冲区**。

关于Go并发我们暂时介绍到这里，至于原子类型，Mutex，channel底层实现这些，留在后期底层剖析再去处理，这里仅仅作为一个引子引出了这些东西。

## CGO

CGO，不是CSGO哈！指的是通过Go去调用C代码，或者由Go来实现一些功能并导出为C函数，供C调用，CGO的演示用例参见[cgo](../cgo)代码包。

现在来说说一些需要注意的事项，C的基本类型和Go的基本类型一一对应是没问题的，但是有一个类型需要特别注意，就是指针类型，C的指针类型可以直接进行数学运算，Go的指针类型更像是一个对象，所以C的指针类型=*T+unsafe.Pointer+uintptr这三个结合体。当我们需要**调用一个接收指针类型的C函数时，传递一个unsafe.Pointer类型**；因为unsafe.Pointer相当于C的 *void，即void指针。 

此外，Go是带有GC和栈动态增长的语言，所以对象地址会变化。这是需要尤为注意的一点！CGO为了保证引用Go对象的C函数访问的内存地址一直有效，会**强制保证C函数执行期间，引用的地址的对象不会被移动**，但是坏处就是如果C函数涉及到耗时操作，会阻碍GC运行，拖垮Go程序性能和吞吐量！解决的方式有很多，包括模拟指针传递，或者暴力一点，直接用值复制。但是都不如直接指针效率高。

此外，**传递给C函数的Pointer所指向的内存区域，不能包含其他的Go指针**，因为CGO仅仅可以确保这个Pointer指向的Go内存不被移动，但是这块内存的子域(就结构体字段或者切片元素)引用的Go内存区域不属于强制管理范畴。

同理，**作为C头文件实现者的Go函数不能返回Pointer**，因为返回值不属于CGO强制管理范畴。

同时**传递给C的Pointer同样具有被更新性**，即如果通过临时变量传递Pointer，则可能出现上面说的那种更新不及时的现象。

来总结下：

- Go调用C传参
  
  - 传递指针使用Pointer。
  
  - 不能出现嵌套指针，因为CGO只能保证最外层指针指向内存的不移动性。
  
  - 长时间持有指针的C函数可能造成Go程阻塞。
  
  - 如果想获取Go对象同时不借助CGO强制固定地址，可以使用对象ID等方法记录一个对象引用，同时把操作对象的实际代码交由Go函数完成，即C函数只是一个“指挥家”，Go接受C函数的“发号施令”。

- Go调用C返回值
  
  - C函数返回值可以任意使用，因为内存地址不变，借此可以突破一些Go的限制；但是C返回了内存地址**必须记得手动释放内存**。

- C调用Go传参
  
  - 暂无

- C调用Go返回值
  
  - Go函数的返回的地址不应该被C使用，因为CGO无法通过返回值固定被C函数使用的内存。

[参考](https://segmentfault.com/a/1190000013590585)

## 汇编

Go的汇编不是C的汇编，C语言的汇编是强绑定于机器和编译器的。Go的汇编是**基于Plan 9汇编改编的，且抽象了部分指令和架构，使之更加通用的Go汇编**。但是我们可以在Go汇编中看到熟悉的影子。

Plan 9汇编不是我们重点关注的内容，感兴趣的读者可以去看看。我们这里更多是基于X64架构讲解Go的汇编。为什么是X64呢？因为服务器基本是X64架构的。

在正式讲解之前，我希望读者拥有部分计算机组成原理的基础。比如了解X64架构的基本执行原理。我们先来看一张图：

![](./x64_arch.svg)

X64是典型的callee saved模式，即被调用者负责保存调用者的寄存器，调用者在自己的栈帧里设置参数和返回地址(CALL指令下条指令的地址，不是返回值地址)。返回值一般通过RAX寄存器保存。

当发生函数调用时：

* 设置函数传参。
* 返回地址压入栈。
* 移交执行权至被调用者。
* 被调用者设置rbp为当前rsp值，即rbp指向新的栈帧的底部。
* 新的rsp随着被调用者执行而变化(其实这里就不管它了)。
* 按需申请空间，存放局部变量等，执行。

当函数调用返回值：

* 通过rbp寄存器找到返回值，保存返回地址。
* 在rbp的位置弹出返回地址(所以这里看到，rbp是为了获取调用者栈帧的栈顶而设置的，然后就可以获取到返回地址)。
* 这是rsp为弹出后的位置(完成被调用者栈帧的释放)。
* 跳转到返回地址继续执行，完成执行权回转。

回顾完X64的基本执行过程，我们来看看Golang的设计，Golang的汇编，为了实现更好的跨平台和统一书写，抽象出了四个寄存器，除了这四个寄存器，**其他架构本身的寄存器依旧是可用的**(比如R8X~R15X等，RAX，RBP，RSP等)。只是这四个寄存器可以更好地实现通用设计。

* PC：对应IP寄存器，保存下一条指令的位置。
* SB：作为全局变量基指针，用来定位全局变量和函数；可以试着把内存理解成一个大号的数组，全局变量和函数的地址都是相对于SB的偏移量，确定了SB的值，加上偏移量，即可在内存中定位到全局变量和函数。
* SP：这是一个伪SP寄存器，因为我们都知道，真的SP(在X64就是RSP)寄存器是栈顶指针；这里的伪SP起到栈底指针的作用，指向当前栈帧的起始位置，用来定位局部变量。
* FP：这依旧是一个伪寄存器，指向调用者的栈帧区域，用来方便被调用者查找参数和写入返回值。

除去这四个伪寄存器，Golang的其他栈帧结构和X64是很像的：

![](./x64_golang_arch.svg)

区分伪SP和真SP的方法很简单：就是真SP没有任何前缀，伪SP寄存器有一个符号作为前缀。

对于一个函数，我们可以通过汇编定义，然后在普通Go文件调用，既不需要导出，也不需要其他什么操作，Go编译器会帮我们完成这一切。这里需要注意一点，就是汇编不可以和CGO一起使用，否则会出现符号解析错误，因为CGO会把.s文件当成C的汇编来处理。

对于一个全局变量，我们也可以指定变量名，变量大小，然后初始化它，但是没法指明它的类型，类型不存在于Golang汇编中。

对于局部变量，则是使用SP来定位设置，但是需要在定义函数时提前指定大小，这里的大小就是全部局部变量的大小(暂时不考虑变量内存复用)。

对于函数**传参，返回值，按照返回值 => 参数；后 => 前压入栈中**。结构体亦是如此；在对结构体完成对齐之后，**结构体成员按照从前向后的顺序入栈**，但是结构体和参数，或者结构体和其他返回值之间依旧是后 => 前的顺序。

Golang的汇编属于自己独有的一套，语法标准啥的和AT&T或者Intel的都有不同。我们这里不会深究，仅仅可以做到阅读汇编代码。如果你想书写汇编代码，或者实现更加复杂的功能，可以阅读Plan 9语法以及一些更加进阶的书籍。

在了解了Golang汇编的内存布局和简单的架构之后，本章目的就完成了！毕竟先读懂，再去写，利用汇编压榨CPU，把性能发挥到极致；或者利用汇编实现一些越权操作，定制化属于我们自己的功能。

## 远程调用

