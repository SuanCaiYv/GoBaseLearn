## slice及其衍生

Go的数组和早期的C/Rust一样，大小都是编译期确定的，即a := [n]int是不可行的，**数组长度必须为常量**。此外，数组长度是数组类型的一部分，不同于Java等语言，数组类型仅仅是元素类型[]，**Go的数组类型 = 元素类型[] + 数组长度**。

也正因为此，Go的数组类型不常用，我们常用的是切片(Slice)，或者叫动态数组，或者说是Java的ArrayList类型，它会动态改变大小。不同于数组，**Slice的类型 = 元素类型[]**，这里不包含长度。

Slice的创建，增长等源码均在runtime/slice.go中实现，感兴趣可以看看，平时我们说一个变量是Slice类型，指的是它是一个**SliceHeader类型**。一个SliceHeader包含三个字段，分别是指向底层元素数组的指针，长度和容量。

``` Golang
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```

容量始终大于等于长度，通过内置函数len()和cap()我们可以获取一个Slice的长度和容量。Slice的一些基本操作，创建，切分我们就不说了。

如果函数传参传递一个数组，则会涉及到调用参数和函数参数的复制，即数组会被复制一份。而如果我们**传参传的是Slice，则复制的是SliceHeader，这仅仅涉及到三个基本类型的复制**，相对开销会小很多。所以在被调函数中我们可以访问到Slice的底层数组并进行修改。

### unsafe

Go保留了指针，但是却给予其一定的限制。所以有时候我们想像C语言那样实现对内存地址的完全访问和控制，就需要unsafe来帮我们。